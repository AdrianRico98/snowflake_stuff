/* INFORMACION DEL ESQUEMA BÁSICA DEL ESQUEMA DE DATOS COMPARTIDO */
SHOW TABLES IN SCHEMA SNOWFLAKE_SAMPLE_DATA.TPCH_SF100;

SELECT 
    table_name,
    column_name,
    data_type,
    character_maximum_length,
    numeric_precision,
    is_nullable
FROM 
    SNOWFLAKE_SAMPLE_DATA.INFORMATION_SCHEMA.COLUMNS
WHERE 
    table_schema = 'TPCH_SF100';
/* --------------------------------------- */
/* QUERIES PARA COMPRENDER EL ESQUEMA/MODELO */
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.REGION;
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.NATION;
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.CUSTOMER LIMIT 10;
SELECT * FROM SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.ORDERS LIMIT 10;
--clientes y nacionalidades
SELECT 
    C.C_CUSTKEY, 
    C.C_NAME, 
    N.N_NAME AS NATION_NAME, 
    R.R_NAME AS REGION_NAME
FROM 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.CUSTOMER C
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.NATION N ON C.C_NATIONKEY = N.N_NATIONKEY
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.REGION R ON N.N_REGIONKEY = R.R_REGIONKEY
LIMIT 20;
-- ordenes y sus clientes
SELECT 
    O.O_ORDERKEY, 
    O.O_ORDERDATE, 
    O.O_TOTALPRICE,
    C.C_NAME, 
    C.C_MKTSEGMENT
FROM 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.ORDERS O
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.CUSTOMER C ON O.O_CUSTKEY = C.C_CUSTKEY
LIMIT 20;
-- partes y proveedores
SELECT 
    PS.PS_PARTKEY, 
    P.P_NAME, 
    P.P_MFGR,
    PS.PS_SUPPKEY, 
    S.S_NAME AS SUPPLIER_NAME,
    PS.PS_AVAILQTY,
    PS.PS_SUPPLYCOST
FROM 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.PARTSUPP PS
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.PART P ON PS.PS_PARTKEY = P.P_PARTKEY
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.SUPPLIER S ON PS.PS_SUPPKEY = S.S_SUPPKEY
LIMIT 20;
-- lineas de pedido con detalle 
SELECT 
    L.L_ORDERKEY, 
    O.O_ORDERDATE,
    P.P_NAME AS PRODUCT_NAME, 
    S.S_NAME AS SUPPLIER_NAME,
    L.L_QUANTITY, 
    L.L_EXTENDEDPRICE,
    L.L_DISCOUNT,
    L.L_EXTENDEDPRICE * (1 - L.L_DISCOUNT) AS FINAL_PRICE
FROM 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.LINEITEM L
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.ORDERS O ON L.L_ORDERKEY = O.O_ORDERKEY
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.PART P ON L.L_PARTKEY = P.P_PARTKEY
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.SUPPLIER S ON L.L_SUPPKEY = S.S_SUPPKEY
LIMIT 20;
-- pedidos por trimestre y segmento de mercado
SELECT 
    YEAR(O.O_ORDERDATE) AS ORDER_YEAR,
    QUARTER(O.O_ORDERDATE) AS ORDER_QUARTER,
    C.C_MKTSEGMENT,
    COUNT(DISTINCT O.O_ORDERKEY) AS ORDER_COUNT,
    SUM(O.O_TOTALPRICE) AS TOTAL_SALES
FROM 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.ORDERS O
JOIN 
    SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.CUSTOMER C ON O.O_CUSTKEY = C.C_CUSTKEY
WHERE 
    O.O_ORDERDATE BETWEEN '1995-01-01' AND '1996-12-31'
GROUP BY 
    ORDER_YEAR, ORDER_QUARTER, C.C_MKTSEGMENT
ORDER BY 
    ORDER_YEAR, ORDER_QUARTER, TOTAL_SALES DESC;
/* --------------------------------------- */
/* PROCEDIMIENTOS ETL */
--preparación del entorno
CREATE OR REPLACE DATABASE MY_ANALYTICS_DB;
USE DATABASE MY_ANALYTICS_DB;
CREATE OR REPLACE SCHEMA ANALYTICS;
USE SCHEMA ANALYTICS;

-- creación de tablas (intermedias y finales)
CREATE OR REPLACE DATABASE MY_ANALYTICS_DB;
USE DATABASE MY_ANALYTICS_DB;
CREATE OR REPLACE SCHEMA ANALYTICS;
USE SCHEMA ANALYTICS;

-- Tablas intermedias para el proceso ETL
CREATE OR REPLACE TABLE STAGE_CUSTOMER_DATA (
    CUSTOMER_KEY INTEGER,
    CUSTOMER_NAME VARCHAR(25),
    NATION_NAME VARCHAR(25),
    REGION_NAME VARCHAR(25),
    MARKET_SEGMENT VARCHAR(10),
    PARSED_ADDRESS VARCHAR(100),
    CONTACT VARCHAR(30)
);

CREATE OR REPLACE TABLE STAGE_ORDER_DATA (
    ORDER_KEY INTEGER,
    ORDER_DATE DATE,
    CUSTOMER_KEY INTEGER,
    TOTAL_PRICE NUMBER(12,2),
    ORDER_STATUS VARCHAR(1),
    ORDER_PRIORITY VARCHAR(15),
    SHIPPING_PRIORITY INTEGER
);

CREATE OR REPLACE TABLE STAGE_LINEITEM_DATA (
    ORDER_KEY INTEGER,
    PART_KEY INTEGER,
    SUPPLIER_KEY INTEGER,
    LINE_NUMBER INTEGER,
    QUANTITY NUMBER(12,2),
    EXTENDED_PRICE NUMBER(12,2),
    DISCOUNT NUMBER(12,2),
    NET_PRICE NUMBER(12,2),
    SHIP_DATE DATE,
    COMMIT_DATE DATE,
    RECEIPT_DATE DATE,
    SHIPMODE VARCHAR(10),
    RETURN_FLAG VARCHAR(1)
);

CREATE OR REPLACE TABLE STAGE_PART_DATA (
    PART_KEY INTEGER,
    PART_NAME VARCHAR(55),
    MANUFACTURER VARCHAR(25),
    BRAND VARCHAR(10),
    TYPE VARCHAR(25),
    SIZE INTEGER,
    CONTAINER VARCHAR(10),
    RETAIL_PRICE NUMBER(12,2),
    CATEGORY VARCHAR(20)
);

-- Tablas finales de análisis
CREATE OR REPLACE TABLE SALES_BY_REGION (
    REGION_NAME VARCHAR(25),
    NATION_NAME VARCHAR(25),
    YEAR_QUARTER VARCHAR(7),
    TOTAL_REVENUE NUMBER(20,2),
    ORDER_COUNT INTEGER,
    AVERAGE_ORDER_VALUE NUMBER(20,2)
);

CREATE OR REPLACE TABLE CUSTOMER_SPENDING (
    CUSTOMER_KEY INTEGER,
    CUSTOMER_NAME VARCHAR(25),
    NATION_NAME VARCHAR(25),
    MARKET_SEGMENT VARCHAR(10),
    TOTAL_SPEND NUMBER(20,2),
    ORDER_COUNT INTEGER,
    FIRST_ORDER_DATE DATE,
    LAST_ORDER_DATE DATE,
    LIFETIME_VALUE NUMBER(20,2)
);

CREATE OR REPLACE TABLE PRODUCT_POPULARITY (
    PART_KEY INTEGER,
    PART_NAME VARCHAR(55),
    MANUFACTURER VARCHAR(25),
    CATEGORY VARCHAR(25),
    QUANTITY_SOLD NUMBER,
    REVENUE_GENERATED NUMBER(20,2),
    AVERAGE_DISCOUNT FLOAT,
    PROFITABILITY_SCORE FLOAT
);

CREATE OR REPLACE TABLE ORDER_PROCESSING_METRICS (
    YEAR_MONTH VARCHAR(7),
    ORDER_COUNT INTEGER,
    AVG_DAYS_TO_SHIP FLOAT,
    MAX_DAYS_TO_SHIP INTEGER,
    MIN_DAYS_TO_SHIP INTEGER,
    ON_TIME_DELIVERY_RATE FLOAT,
    RETURN_RATE FLOAT
);

--procedimiento secuencial
CREATE OR REPLACE PROCEDURE ETL_SEQUENTIAL()
RETURNS VARCHAR
LANGUAGE SQL
AS
$$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    etl_phase VARCHAR;
BEGIN
    start_time := CURRENT_TIMESTAMP();
    etl_phase := 'Iniciando proceso ETL secuencial';
    
    -- FASE 1: Extracción y transformación inicial de datos (preparación)
    etl_phase := 'FASE 1: Extracción y preparación de datos';
    
    -- Limpiar tablas staging
    TRUNCATE TABLE STAGE_CUSTOMER_DATA;
    TRUNCATE TABLE STAGE_ORDER_DATA;
    TRUNCATE TABLE STAGE_LINEITEM_DATA;
    TRUNCATE TABLE STAGE_PART_DATA;
    
    -- 1.1 Extraer y transformar datos de clientes
    INSERT INTO STAGE_CUSTOMER_DATA
    SELECT 
        C.C_CUSTKEY AS CUSTOMER_KEY,
        C.C_NAME AS CUSTOMER_NAME,
        N.N_NAME AS NATION_NAME,
        R.R_NAME AS REGION_NAME,
        C.C_MKTSEGMENT AS MARKET_SEGMENT,
        C.C_ADDRESS AS PARSED_ADDRESS,
        C.C_PHONE AS CONTACT
    FROM 
        SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.CUSTOMER C
    JOIN 
        SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.NATION N ON C.C_NATIONKEY = N.N_NATIONKEY
    JOIN 
        SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.REGION R ON N.N_REGIONKEY = R.R_REGIONKEY;
    
    -- 1.2 Extraer y transformar datos de órdenes
    INSERT INTO STAGE_ORDER_DATA
    SELECT 
        O.O_ORDERKEY AS ORDER_KEY,
        O.O_ORDERDATE AS ORDER_DATE,
        O.O_CUSTKEY AS CUSTOMER_KEY,
        O.O_TOTALPRICE AS TOTAL_PRICE,
        O.O_ORDERSTATUS AS ORDER_STATUS,
        O.O_ORDERPRIORITY AS ORDER_PRIORITY,
        O.O_SHIPPRIORITY AS SHIPPING_PRIORITY
    FROM 
        SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.ORDERS O
    WHERE 
        O.O_ORDERDATE >= '1995-01-01';
    
    -- 1.3 Extraer y transformar datos de líneas de pedido
    INSERT INTO STAGE_LINEITEM_DATA
    SELECT 
        L.L_ORDERKEY AS ORDER_KEY,
        L.L_PARTKEY AS PART_KEY,
        L.L_SUPPKEY AS SUPPLIER_KEY,
        L.L_LINENUMBER AS LINE_NUMBER,
        L.L_QUANTITY AS QUANTITY,
        L.L_EXTENDEDPRICE AS EXTENDED_PRICE,
        L.L_DISCOUNT AS DISCOUNT,
        L.L_EXTENDEDPRICE * (1 - L.L_DISCOUNT) AS NET_PRICE,
        L.L_SHIPDATE AS SHIP_DATE,
        L.L_COMMITDATE AS COMMIT_DATE,
        L.L_RECEIPTDATE AS RECEIPT_DATE,
        L.L_SHIPMODE AS SHIPMODE,
        L.L_RETURNFLAG AS RETURN_FLAG
    FROM 
        SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.LINEITEM L
    JOIN 
        STAGE_ORDER_DATA O ON L.L_ORDERKEY = O.ORDER_KEY;
    
    -- 1.4 Extraer y transformar datos de partes/productos
    INSERT INTO STAGE_PART_DATA
    SELECT 
        P.P_PARTKEY AS PART_KEY,
        P.P_NAME AS PART_NAME,
        P.P_MFGR AS MANUFACTURER,
        P.P_BRAND AS BRAND,
        P.P_TYPE AS TYPE,
        P.P_SIZE AS SIZE,
        P.P_CONTAINER AS CONTAINER,
        P.P_RETAILPRICE AS RETAIL_PRICE,
        CASE 
            WHEN P.P_TYPE LIKE '%PROMO%' THEN 'PROMOTIONAL'
            WHEN P.P_TYPE LIKE '%ECONOMY%' THEN 'ECONOMY'
            WHEN P.P_TYPE LIKE '%LARGE%' THEN 'LARGE'
            ELSE 'STANDARD'
        END AS CATEGORY
    FROM 
        SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.PART P
    JOIN 
        (SELECT DISTINCT PART_KEY FROM STAGE_LINEITEM_DATA) L ON P.P_PARTKEY = L.PART_KEY;
    
    -- FASE 2: Análisis y agregaciones
    etl_phase := 'FASE 2: Análisis y agregaciones';
    
    -- Limpiar tablas de análisis
    TRUNCATE TABLE SALES_BY_REGION;
    TRUNCATE TABLE CUSTOMER_SPENDING;
    TRUNCATE TABLE PRODUCT_POPULARITY;
    TRUNCATE TABLE ORDER_PROCESSING_METRICS;
    
    -- 2.1 Calcular ventas por región
    INSERT INTO SALES_BY_REGION
    SELECT 
        C.REGION_NAME,
        C.NATION_NAME,
        CONCAT(YEAR(O.ORDER_DATE), '-Q', QUARTER(O.ORDER_DATE)) AS YEAR_QUARTER,
        SUM(L.NET_PRICE) AS TOTAL_REVENUE,
        COUNT(DISTINCT O.ORDER_KEY) AS ORDER_COUNT,
        SUM(L.NET_PRICE) / NULLIF(COUNT(DISTINCT O.ORDER_KEY), 0) AS AVERAGE_ORDER_VALUE
    FROM 
        STAGE_LINEITEM_DATA L
    JOIN 
        STAGE_ORDER_DATA O ON L.ORDER_KEY = O.ORDER_KEY
    JOIN 
        STAGE_CUSTOMER_DATA C ON O.CUSTOMER_KEY = C.CUSTOMER_KEY
    GROUP BY 
        C.REGION_NAME, C.NATION_NAME, YEAR_QUARTER;
    
    -- 2.2 Calcular gasto por cliente
    INSERT INTO CUSTOMER_SPENDING
    SELECT 
        C.CUSTOMER_KEY,
        C.CUSTOMER_NAME,
        C.NATION_NAME,
        C.MARKET_SEGMENT,
        SUM(O.TOTAL_PRICE) AS TOTAL_SPEND,
        COUNT(DISTINCT O.ORDER_KEY) AS ORDER_COUNT,
        MIN(O.ORDER_DATE) AS FIRST_ORDER_DATE,
        MAX(O.ORDER_DATE) AS LAST_ORDER_DATE,
        SUM(O.TOTAL_PRICE) * (1 + 0.1 * DATEDIFF('MONTH', MIN(O.ORDER_DATE), MAX(O.ORDER_DATE))/12) AS LIFETIME_VALUE
    FROM 
        STAGE_CUSTOMER_DATA C
    JOIN 
        STAGE_ORDER_DATA O ON C.CUSTOMER_KEY = O.CUSTOMER_KEY
    GROUP BY 
        C.CUSTOMER_KEY, C.CUSTOMER_NAME, C.NATION_NAME, C.MARKET_SEGMENT;
    
    -- 2.3 Calcular popularidad de productos
    INSERT INTO PRODUCT_POPULARITY
    SELECT 
        P.PART_KEY,
        P.PART_NAME,
        P.MANUFACTURER,
        P.CATEGORY,
        SUM(L.QUANTITY) AS QUANTITY_SOLD,
        SUM(L.NET_PRICE) AS REVENUE_GENERATED,
        AVG(L.DISCOUNT) AS AVERAGE_DISCOUNT,
        SUM(L.NET_PRICE) / NULLIF(SUM(L.QUANTITY * P.RETAIL_PRICE), 0) * 100 AS PROFITABILITY_SCORE
    FROM 
        STAGE_PART_DATA P
    JOIN 
        STAGE_LINEITEM_DATA L ON P.PART_KEY = L.PART_KEY
    GROUP BY 
        P.PART_KEY, P.PART_NAME, P.MANUFACTURER, P.CATEGORY;
    
    -- 2.4 Calcular métricas de procesamiento de pedidos
    INSERT INTO ORDER_PROCESSING_METRICS
    SELECT 
        CONCAT(YEAR(O.ORDER_DATE), '-', LPAD(MONTH(O.ORDER_DATE), 2, '0')) AS YEAR_MONTH,
        COUNT(DISTINCT O.ORDER_KEY) AS ORDER_COUNT,
        AVG(DATEDIFF('DAY', O.ORDER_DATE, L.SHIP_DATE)) AS AVG_DAYS_TO_SHIP,
        MAX(DATEDIFF('DAY', O.ORDER_DATE, L.SHIP_DATE)) AS MAX_DAYS_TO_SHIP,
        MIN(DATEDIFF('DAY', O.ORDER_DATE, L.SHIP_DATE)) AS MIN_DAYS_TO_SHIP,
        SUM(CASE WHEN DATEDIFF('DAY', O.ORDER_DATE, L.SHIP_DATE) <= 30 THEN 1 ELSE 0 END) / 
            NULLIF(COUNT(*), 0) * 100 AS ON_TIME_DELIVERY_RATE,
        SUM(CASE WHEN L.RETURN_FLAG = 'R' THEN 1 ELSE 0 END) / 
            NULLIF(COUNT(*), 0) * 100 AS RETURN_RATE
    FROM 
        STAGE_ORDER_DATA O
    JOIN 
        STAGE_LINEITEM_DATA L ON O.ORDER_KEY = L.ORDER_KEY
    GROUP BY 
        YEAR_MONTH;
    
    end_time := CURRENT_TIMESTAMP();
    
    RETURN 'ETL secuencial completado con éxito en ' || 
            DATEDIFF('MILLISECOND', start_time, end_time)/1000 || 
            ' segundos. Última fase: ' || etl_phase;
END;
$$;

CALL ETL_SEQUENTIAL();

CREATE OR REPLACE PROCEDURE ETL_ASYNC()
RETURNS VARCHAR
LANGUAGE SQL
AS
$$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    etl_phase VARCHAR;
BEGIN
    start_time := CURRENT_TIMESTAMP();
    etl_phase := 'Iniciando proceso ETL asíncrono';
    
    -- FASE 1: Extracción y transformación inicial de datos (preparación)
    etl_phase := 'FASE 1: Extracción y preparación de datos';
    
    -- Limpiar tablas staging
    TRUNCATE TABLE STAGE_CUSTOMER_DATA;
    TRUNCATE TABLE STAGE_ORDER_DATA;
    TRUNCATE TABLE STAGE_LINEITEM_DATA;
    TRUNCATE TABLE STAGE_PART_DATA;
    
    -- 1.1 Extraer y transformar datos de clientes (ASYNC)
    LET customer_load RESULTSET := ASYNC (
        INSERT INTO STAGE_CUSTOMER_DATA
        SELECT 
            C.C_CUSTKEY AS CUSTOMER_KEY,
            C.C_NAME AS CUSTOMER_NAME,
            N.N_NAME AS NATION_NAME,
            R.R_NAME AS REGION_NAME,
            C.C_MKTSEGMENT AS MARKET_SEGMENT,
            C.C_ADDRESS AS PARSED_ADDRESS,
            C.C_PHONE AS CONTACT
        FROM 
            SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.CUSTOMER C
        JOIN 
            SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.NATION N ON C.C_NATIONKEY = N.N_NATIONKEY
        JOIN 
            SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.REGION R ON N.N_REGIONKEY = R.R_REGIONKEY
    );
    
    -- 1.2 Extraer y transformar datos de órdenes (ASYNC)
    LET orders_load RESULTSET := ASYNC (
        INSERT INTO STAGE_ORDER_DATA
        SELECT 
            O.O_ORDERKEY AS ORDER_KEY,
            O.O_ORDERDATE AS ORDER_DATE,
            O.O_CUSTKEY AS CUSTOMER_KEY,
            O.O_TOTALPRICE AS TOTAL_PRICE,
            O.O_ORDERSTATUS AS ORDER_STATUS,
            O.O_ORDERPRIORITY AS ORDER_PRIORITY,
            O.O_SHIPPRIORITY AS SHIPPING_PRIORITY
        FROM 
            SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.ORDERS O
        WHERE 
            O.O_ORDERDATE >= '1995-01-01'
    );
    
    -- Esperamos a que las cargas iniciales terminen antes de procesar líneas de pedido
    AWAIT orders_load;
    
    -- 1.3 Extraer y transformar datos de líneas de pedido (depende de orders_load)
    LET lineitem_load RESULTSET := ASYNC (
        INSERT INTO STAGE_LINEITEM_DATA
        SELECT 
            L.L_ORDERKEY AS ORDER_KEY,
            L.L_PARTKEY AS PART_KEY,
            L.L_SUPPKEY AS SUPPLIER_KEY,
            L.L_LINENUMBER AS LINE_NUMBER,
            L.L_QUANTITY AS QUANTITY,
            L.L_EXTENDEDPRICE AS EXTENDED_PRICE,
            L.L_DISCOUNT AS DISCOUNT,
            L.L_EXTENDEDPRICE * (1 - L.L_DISCOUNT) AS NET_PRICE,
            L.L_SHIPDATE AS SHIP_DATE,
            L.L_COMMITDATE AS COMMIT_DATE,
            L.L_RECEIPTDATE AS RECEIPT_DATE,
            L.L_SHIPMODE AS SHIPMODE,
            L.L_RETURNFLAG AS RETURN_FLAG
        FROM 
            SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.LINEITEM L
        JOIN 
            STAGE_ORDER_DATA O ON L.L_ORDERKEY = O.ORDER_KEY
    );
    
    -- Esperamos a que se carguen los datos de líneas de pedido
    AWAIT lineitem_load;
    
    -- 1.4 Extraer y transformar datos de partes/productos (depende de lineitem_load)
    LET parts_load RESULTSET := ASYNC (
        INSERT INTO STAGE_PART_DATA
        SELECT 
            P.P_PARTKEY AS PART_KEY,
            P.P_NAME AS PART_NAME,
            P.P_MFGR AS MANUFACTURER,
            P.P_BRAND AS BRAND,
            P.P_TYPE AS TYPE,
            P.P_SIZE AS SIZE,
            P.P_CONTAINER AS CONTAINER,
            P.P_RETAILPRICE AS RETAIL_PRICE,
            CASE 
                WHEN P.P_TYPE LIKE '%PROMO%' THEN 'PROMOTIONAL'
                WHEN P.P_TYPE LIKE '%ECONOMY%' THEN 'ECONOMY'
                WHEN P.P_TYPE LIKE '%LARGE%' THEN 'LARGE'
                ELSE 'STANDARD'
            END AS CATEGORY
        FROM 
            SNOWFLAKE_SAMPLE_DATA.TPCH_SF100.PART P
        JOIN 
            (SELECT DISTINCT PART_KEY FROM STAGE_LINEITEM_DATA) L ON P.P_PARTKEY = L.PART_KEY
    );
    
    -- Esperamos a que todos los datos de staging estén listos
    AWAIT customer_load;
    AWAIT parts_load;
    
    -- FASE 2: Análisis y agregaciones (pueden ejecutarse en paralelo una vez que los datos están listos)
    etl_phase := 'FASE 2: Análisis y agregaciones';
    
    -- Limpiar tablas de análisis
    TRUNCATE TABLE SALES_BY_REGION;
    TRUNCATE TABLE CUSTOMER_SPENDING;
    TRUNCATE TABLE PRODUCT_POPULARITY;
    TRUNCATE TABLE ORDER_PROCESSING_METRICS;
    
    -- 2.1 Calcular ventas por región (ASYNC)
    ASYNC (
        INSERT INTO SALES_BY_REGION
        SELECT 
            C.REGION_NAME,
            C.NATION_NAME,
            CONCAT(YEAR(O.ORDER_DATE), '-Q', QUARTER(O.ORDER_DATE)) AS YEAR_QUARTER,
            SUM(L.NET_PRICE) AS TOTAL_REVENUE,
            COUNT(DISTINCT O.ORDER_KEY) AS ORDER_COUNT,
            SUM(L.NET_PRICE) / NULLIF(COUNT(DISTINCT O.ORDER_KEY), 0) AS AVERAGE_ORDER_VALUE
        FROM 
            STAGE_LINEITEM_DATA L
        JOIN 
            STAGE_ORDER_DATA O ON L.ORDER_KEY = O.ORDER_KEY
        JOIN 
            STAGE_CUSTOMER_DATA C ON O.CUSTOMER_KEY = C.CUSTOMER_KEY
        GROUP BY 
            C.REGION_NAME, C.NATION_NAME, YEAR_QUARTER
    );
    
    -- 2.2 Calcular gasto por cliente (ASYNC)
    ASYNC (
        INSERT INTO CUSTOMER_SPENDING
        SELECT 
            C.CUSTOMER_KEY,
            C.CUSTOMER_NAME,
            C.NATION_NAME,
            C.MARKET_SEGMENT,
            SUM(O.TOTAL_PRICE) AS TOTAL_SPEND,
            COUNT(DISTINCT O.ORDER_KEY) AS ORDER_COUNT,
            MIN(O.ORDER_DATE) AS FIRST_ORDER_DATE,
            MAX(O.ORDER_DATE) AS LAST_ORDER_DATE,
            SUM(O.TOTAL_PRICE) * (1 + 0.1 * DATEDIFF('MONTH', MIN(O.ORDER_DATE), MAX(O.ORDER_DATE))/12) AS LIFETIME_VALUE
        FROM 
            STAGE_CUSTOMER_DATA C
        JOIN 
            STAGE_ORDER_DATA O ON C.CUSTOMER_KEY = O.CUSTOMER_KEY
        GROUP BY 
            C.CUSTOMER_KEY, C.CUSTOMER_NAME, C.NATION_NAME, C.MARKET_SEGMENT
    );
    
    -- 2.3 Calcular popularidad de productos (ASYNC)
    ASYNC (
        INSERT INTO PRODUCT_POPULARITY
        SELECT 
            P.PART_KEY,
            P.PART_NAME,
            P.MANUFACTURER,
            P.CATEGORY,
            SUM(L.QUANTITY) AS QUANTITY_SOLD,
            SUM(L.NET_PRICE) AS REVENUE_GENERATED,
            AVG(L.DISCOUNT) AS AVERAGE_DISCOUNT,
            SUM(L.NET_PRICE) / NULLIF(SUM(L.QUANTITY * P.RETAIL_PRICE), 0) * 100 AS PROFITABILITY_SCORE
        FROM 
            STAGE_PART_DATA P
        JOIN 
            STAGE_LINEITEM_DATA L ON P.PART_KEY = L.PART_KEY
        GROUP BY 
            P.PART_KEY, P.PART_NAME, P.MANUFACTURER, P.CATEGORY
    );
    
    -- 2.4 Calcular métricas de procesamiento de pedidos (ASYNC)
    ASYNC (
        INSERT INTO ORDER_PROCESSING_METRICS
        SELECT 
            CONCAT(YEAR(O.ORDER_DATE), '-', LPAD(MONTH(O.ORDER_DATE), 2, '0')) AS YEAR_MONTH,
            COUNT(DISTINCT O.ORDER_KEY) AS ORDER_COUNT,
            AVG(DATEDIFF('DAY', O.ORDER_DATE, L.SHIP_DATE)) AS AVG_DAYS_TO_SHIP,
            MAX(DATEDIFF('DAY', O.ORDER_DATE, L.SHIP_DATE)) AS MAX_DAYS_TO_SHIP,
            MIN(DATEDIFF('DAY', O.ORDER_DATE, L.SHIP_DATE)) AS MIN_DAYS_TO_SHIP,
            SUM(CASE WHEN DATEDIFF('DAY', O.ORDER_DATE, L.SHIP_DATE) <= 30 THEN 1 ELSE 0 END) / 
                NULLIF(COUNT(*), 0) * 100 AS ON_TIME_DELIVERY_RATE,
            SUM(CASE WHEN L.RETURN_FLAG = 'R' THEN 1 ELSE 0 END) / 
                NULLIF(COUNT(*), 0) * 100 AS RETURN_RATE
        FROM 
            STAGE_ORDER_DATA O
        JOIN 
            STAGE_LINEITEM_DATA L ON O.ORDER_KEY = L.ORDER_KEY
        GROUP BY 
            YEAR_MONTH
    );
    
    -- Esperar a que todos los trabajos asíncronos finalicen
    AWAIT ALL;
    
    end_time := CURRENT_TIMESTAMP();
    
    RETURN 'ETL async completado con éxito en ' || 
            DATEDIFF('MILLISECOND', start_time, end_time)/1000 || 
            ' segundos. Última fase: ' || etl_phase;
END;
$$;

CALL ETL_ASYNC();




